F1 = 0
F2 = 1
F3 = 0
F4 = -1

def sequence(length, step)
  batches = (length / 4) + 1
  ([F1, F2, F3, F4].map { |num| [num] * step }.flatten * batches).slice(1..length)
end

num = '59796332430280528211060657577039744056609636505111313336094865900635343682296702094018432765613019371234483818415934914575717134617783515237300919201989706451524069044921384738930172026234872525254689609787752401342687098918804210494391161531008341329016626922990938854681575317559821067933058630688365067790812341475168200215494963690593873250884807840611487288560291748414160551508979374335267106414602526249401281066501677212002980616711058803845336067123298983258010079178111678678796586176705130938139337603538683803154824502761228184209473344607055926120829751532887810487164482307564712692208157118923502010028250886290873995577102178526942152'
# num = '03036732577212944063491565474664'
phases = 100

def answer1(num, phases)
  phases.times.inject(num.chars.map(&:to_i)) { |result, _time|
    result.length.times.map { |step|
      sequence(result.length, step + 1).zip(result).map { |(a, b)| a * b }.sum.abs % 10
    }
  }.first(8).join
end

def answer2(num, phases)
  digits = num.chars.map(&:to_i) * 10000
  offset = digits.first(7).join.to_i

  phases.times.inject(digits[offset..]) { |current, _time|
    sum = current.sum

    current.map { |digit|
      (sum.abs % 10).tap { sum -= digit }
    }
  }.first(8).join
end


p answer2(num, phases)
